//* Licensed Materials - Property of IBM                              *
//* com.ibm.zurich.idmx.2.3.40                                        *
//* (C) Copyright IBM Corp. 2013. All Rights Reserved.                *
//* US Government Users Restricted Rights - Use, duplication or       *
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp. *
//*/**/****************************************************************
package com.ibm.zurich.idmx.issuance;

import java.math.BigInteger;
import java.net.URI;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.ibm.zurich.idmx.api.RecipientInterface;
import com.ibm.zurich.idmx.dm.Commitment;
import com.ibm.zurich.idmx.dm.CommitmentOpening;
import com.ibm.zurich.idmx.dm.Credential;
import com.ibm.zurich.idmx.dm.Values;
import com.ibm.zurich.idmx.dm.structure.AttributeStructure;
import com.ibm.zurich.idmx.dm.structure.CredentialStructure;
import com.ibm.zurich.idmx.dm.structure.AttributeStructure.IssuanceMode;
import com.ibm.zurich.idmx.issuance.Message.IssuanceProtocolValues;
import com.ibm.zurich.idmx.key.IssuerPublicKey;
import com.ibm.zurich.idmx.showproof.Proof;
import com.ibm.zurich.idmx.showproof.sval.SValue;
import com.ibm.zurich.idmx.smartcard.IdemixProofCommitment;
import com.ibm.zurich.idmx.smartcard.IdemixProofResponse;
import com.ibm.zurich.idmx.smartcard.IdemixProofSpec;
import com.ibm.zurich.idmx.smartcard.IdemixSmartcardManager;
import com.ibm.zurich.idmx.utils.Constants;
import com.ibm.zurich.idmx.utils.GroupParameters;
import com.ibm.zurich.idmx.utils.SystemParameters;
import com.ibm.zurich.idmx.utils.Utils;
import com.ibm.zurich.idmx.utils.perf.Exponentiation;

/**
 * The credential recipient (or user) for the CL credential issuance.
 * 
 * @see Issuer
 */
@Deprecated
public class Recipient implements RecipientInterface {

    /** Logger. */
    private static Logger log = Logger.getLogger(Recipient.class.getName());

    /** Issuance specification for the credential that is retrieved. */
    private final IssuanceSpec spec;
    /** Credential structure. */
    private final CredentialStructure credStruct;

    /** Smartcard manager*/
    private final IdemixSmartcardManager smartcardManager;
    private URI nameOfSmartcard;
    private URI credNameOnSmartcard;
    
    /** Values needed during the issuance protocol. */
    private final Values values;

    /** Random values for the hidden/committed attributes used during a proof. */
    private final HashMap<String, BigInteger> mTilde;
    /** Nonce generated by the recipient (for the proof of the verifier). */
    private BigInteger n2;
    /** Randomization value for the signature (Recipient's contribution). */
    private BigInteger vPrime;
    /** Common value for the proof in the first round. */
    private BigInteger capU;

    /** Convenience: Issuer public key. */
    private final IssuerPublicKey ipk;
    /** Convenience: System parameters. */
    private final SystemParameters sp;
    /** Convenience: Group parameters. */
    private final GroupParameters gp;

    /**
     * Constructor to create the Recipient protocol end point, who will receive
     * the credential.
     * 
     * @param issuanceSpec
     *            Issuance specification.
     * @param theValues
     *            Values of the attributes that will be contained in the
     *            credential to be issued.
     */
    public Recipient(final IssuanceSpec issuanceSpec,
                     final Values theValues) {
      this(issuanceSpec, null, theValues);
    }
    
    public Recipient(final IssuanceSpec issuanceSpec,
            final IdemixSmartcardManager smartcardManager,
            final Values theValues) {
        super();

        if (issuanceSpec == null) {
            throw new RuntimeException("Recipient instantiated without the "
                    + "necessary values.");
        }

        spec = issuanceSpec;

        ipk = issuanceSpec.getPublicKey();
        gp = ipk.getGroupParams();
        sp = gp.getSystemParams();

        this.smartcardManager = smartcardManager;

        credStruct = issuanceSpec.getCredentialStructure();
        values = theValues;
        mTilde = new HashMap<String, BigInteger>();

        // adding masterSecret value to values
        credStruct.verifyRecipientValues(values);
    }



    /**
     * @param attStructs
     *            Attribute structures.
     * @param capR
     *            Bases form the issuer public key.
     * @param n
     *            Modulus.
     * @return Exponentiations for hidden and committed attributes (when
     *         computing the common value <tt>U</tt>).
     */
    private Vector<Exponentiation> addAttExpos(
            final Vector<AttributeStructure> attStructs,
            final BigInteger[] capR, final BigInteger n) {
        Vector<Exponentiation> expos = new Vector<Exponentiation>();
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() == IssuanceMode.KNOWN) {
                continue;
            }
            BigInteger value = (BigInteger) values.getValue(attStruct);
            expos.add(new Exponentiation(capR[attStruct.getKeyIndex()], value,
                    n));
        }
        return expos;
    }

    /**
     * @param attStructs
     *            Attribute structures.
     * @param capR
     *            Bases form the issuer public key.
     * @param n
     *            Modulus.
     * @return Exponentiations for hidden and committed attributes (when
     *         computing the t-value <tt>UTilde</tt>).
     */
    private Vector<Exponentiation> addTildeAttExpos(
            final Vector<AttributeStructure> attStructs,
            final BigInteger[] capR, final BigInteger n) {
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() == IssuanceMode.KNOWN) {
                continue;
            }
            BigInteger theMTilde = mTilde.get(attStruct.getName());
            expos.add(new Exponentiation(capR[attStruct.getKeyIndex()],
                    theMTilde, n));
            log.log(Level.FINE, "adding attribute: " + attStruct.getName());
        }
        return expos;
    }

    /**
     * Adds the random values for all hidden and committed attributes. Those
     * values will be used to compute the t-value of the proof in the first
     * round.
     * 
     * @param attStructs
     *            Attribute structures.
     */
    private void setMTildes(
            final Vector<? extends AttributeStructure> attStructs) {
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() != IssuanceMode.KNOWN) {
                int bitlength = sp.getL_m() + sp.getL_Phi() + sp.getL_H() + 1;
                mTilde.put(attStruct.getName(),
                        Utils.computeRandomNumberSymmetric(bitlength));
            }
        }
    }

    /**
     * Computes the set of additional commitments for the committed attributes
     * (math spec 1.3.2).
     * 
     * @param attStructs
     *            Attribute structures.
     * @return <tt>CTilde</tt>.
     */
    private HashMap<String, Commitment> getCapCTilde(
            final Vector<AttributeStructure> attStructs) {
        int bitlength = sp.getL_n() + 2 * sp.getL_Phi() + sp.getL_H();

        HashMap<String, Commitment> capCTildes = new HashMap<String, Commitment>();

        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() != IssuanceMode.COMMITTED) {
                continue;
            }
            final BigInteger rTilde = Utils
                    .computeRandomNumberSymmetric(bitlength);
            final String theName = attStruct.getName();
            final Commitment capC = (Commitment) values
                    .get(attStruct.getName()).getContent();
            final BigInteger theMTilde = mTilde.get(theName);

            // the exponent is set to the mTilde of the attribute which
            // corresponds to the commitment!
            // the attribute's mTilde was set to some random value before.
            final CommitmentOpening capCTilde = new CommitmentOpening(
                    capC.getCapR(), theMTilde, capC.getCapS(), rTilde,
                    capC.getN(), sp.getL_n());

            capCTildes.put(theName, capCTilde);
        }
        return capCTildes;
    }

    /**
     * @param attStructs
     *            Attribute structures.
     * @param leftHandSide
     *            Left hand side of the proof.
     * @param capUTilde
     *            T-value of the proof.
     * @param capCTilde
     *            Additional commitments.
     * @param nymTilde
     *            Commitment for the pseudonym.
     * @param domNymTilde
     *            Commitment for the domain pseudonym.
     * @param n1
     *            Nonce for this challenge.
     * @return Fiat-Shamir challenge.
     */
    private BigInteger compute_C(final Vector<AttributeStructure> attStructs,
            final BigInteger leftHandSide, final BigInteger capUTilde,
            final HashMap<String, Commitment> capCTilde,
            final BigInteger nymTilde, final BigInteger domNymTilde,
            final BigInteger n1) {

        final HashMap<String, BigInteger> commitments;
        commitments = new HashMap<String, BigInteger>();
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() == IssuanceMode.COMMITTED) {
                final String theName = attStruct.getName();
                commitments
                        .put(theName, capCTilde.get(theName).getCommitment());
            }
        }

        BigInteger theNym = null;
        BigInteger theDomNym = null;
        BigInteger challenge = Utils.computeFSChallenge(sp, spec.getContext(), leftHandSide,
                attStructs, values, theNym, theDomNym, capUTilde, commitments,
                nymTilde, domNymTilde, n1);
          return challenge;
    }

    /**
     * 
     * @see com.ibm.zurich.idmx.issuance.RecipientInterface#round1(com.ibm.zurich
     *      .idmx.issuance.Message)
     */
    public final Message round1(final Message message0) {
      return round1(message0, null, null);
    }
    
    public final Message round1(final Message message0, final URI nameOfSmartcard, final URI credNameOnSmartcard) {

        IdemixProofCommitment scCom = null;
        byte[] smartcardNonce = null;
      
        // nonce from Issuer
        assert (message0 != null);
        
        this.nameOfSmartcard = nameOfSmartcard;
        this.credNameOnSmartcard = credNameOnSmartcard;
        if(credStruct.isOnSmartcard()) {
          if(nameOfSmartcard == null) {
            throw new RuntimeException("This credential needs a secret on a smartcard. Please set the name of the card.");
          }
          if(credNameOnSmartcard == null) {
            throw new RuntimeException("This credential needs a secret on a smartcard. Please set the name of the credential (as it is known on the smartcard).");
          }
          if(smartcardManager == null) {
            throw new RuntimeException("Smartcard manager has not been loaded. Aborting.");
          }
          if(!smartcardManager.credentialExists(nameOfSmartcard, credNameOnSmartcard)) {
            throw new RuntimeException("Smartcard manager does not know about the card/credential. Aborting.");
          }
          // Sanity checks
          BigInteger S = smartcardManager.getSOfCredential(nameOfSmartcard, credNameOnSmartcard);
          BigInteger R0 = smartcardManager.getR0OfCredential(nameOfSmartcard, credNameOnSmartcard);
          BigInteger N = smartcardManager.getNOfCredential(nameOfSmartcard, credNameOnSmartcard);
          if (! S.equals(ipk.getCapS())) {
            throw new RuntimeException("Smartcard and Idemix don't agree on S (randomization base)");
          }
          if (! R0.equals(ipk.getCapR()[IssuanceSpec.SMARTCARD_SECRET_INDEX])) {
            throw new RuntimeException("Smartcard and Idemix don't agree on R0 (smartcard secret base)");
          }
          if (! N.equals(ipk.getN())) {
            throw new RuntimeException("Smartcard and Idemix don't agree on N (modulus)");
          }
          if (sp.getL_H() != smartcardManager.getChallengeSizeBytes()*8) {
            throw new RuntimeException("Incompatible challenge length Idemix/Smartcard");
          }
          if (sp.getL_Phi() != smartcardManager.getStatisticalHidingSizeBytes()*8) {
            throw new RuntimeException("Incompatible statistical hiding parameter Idemix/Smartcard");
          }
          // Prepare ZK-proofs on smartcard
          IdemixProofSpec spec = smartcardManager.idemixProofSpecFactory();
          spec.addCredentialProof(nameOfSmartcard, credNameOnSmartcard);
          // TODO(enr): add pseudonyms and domain pseudonyms to spec
          scCom = smartcardManager.prepareProof(spec);
        }

        BigInteger theNonce1 = message0
                .getIssuanceElement(IssuanceProtocolValues.nonce);

        Vector<AttributeStructure> attStructs = credStruct
                .getAttributeStructs();

        // RSA modulus n
        final BigInteger n = ipk.getN();
        // key R elements
        final BigInteger[] capR = ipk.getCapR();

        // [spec: IssueCertificateProtocol 1.1] choose v' \in +/- \{0,1\}^(l_n +
        // l_Phi)
        int bitlength = sp.getL_n() + sp.getL_Phi();
        vPrime = Utils.computeRandomNumberSymmetric(bitlength);

        // [spec: IssueCertificateProtocol 1.2] compute capU
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        expos.add(new Exponentiation(ipk.getCapS(), vPrime, n));
        expos.addAll(addAttExpos(attStructs, capR, n));
        BigInteger capUPrime = Utils.multiExpMul(expos, n);     
        BigInteger fragment = computeFragment(nameOfSmartcard, credNameOnSmartcard);
        capU = capUPrime.multiply(fragment).mod(n);

        bitlength = sp.getL_n() + 2 * sp.getL_Phi() + sp.getL_H();
        final BigInteger vTildePrime = Utils
                .computeRandomNumberSymmetric(bitlength);

        setMTildes(attStructs);

        // compute UTilde
        final Vector<Exponentiation> expos1 = new Vector<Exponentiation>();
        expos1.add(new Exponentiation(ipk.getCapS(), vTildePrime, n));

        // add tilde values for hidden and committed attributes
        expos1.addAll(addTildeAttExpos(attStructs, capR, n));
        final BigInteger capUTildePrime = Utils.multiExpMul(expos1, n);
        final BigInteger capUTilde = capUTildePrime.multiply(
            computeCommitment(nameOfSmartcard, credNameOnSmartcard, scCom)).mod(n);

        BigInteger nymTilde = null;
        BigInteger domNymTilde = null;

        // CTilde: may be empty (non-null). We know the commitment opening!
        final HashMap<String, Commitment> capCTilde = getCapCTilde(attStructs);

        // compute the Fiat-Shamir hash.
        BigInteger challenge = compute_C(attStructs, capU, capUTilde,
                capCTilde, nymTilde, domNymTilde, theNonce1);
        IdemixProofResponse scResp = null;
        if (nameOfSmartcard != null) {
          // When a smartcard is present, we will apply the hash function TWICE
          // (Smartcard expects a hash pre-image)
          byte[] preimage = challenge.toByteArray();
          smartcardNonce = smartcardManager.prepareNonce(scCom);
          challenge = smartcardManager.computeChallenge(preimage, smartcardNonce);
          scResp = smartcardManager.finalizeZkProof(scCom, preimage, smartcardNonce);
        }

        final HashMap<String, SValue> sValues = getSValues(attStructs,
          capCTilde, challenge);
        BigInteger vHatPrime;
        if (nameOfSmartcard == null) {
          vHatPrime = Utils.computeResponse(vTildePrime, challenge, vPrime);
        } else {
          BigInteger vHatPrime1 = scResp.responseForCredentialRandomizer(nameOfSmartcard, credNameOnSmartcard);
          BigInteger vHatPrime2 = Utils.computeResponse(vTildePrime, challenge, vPrime);
          vHatPrime = vHatPrime1.add(vHatPrime2);
          
          BigInteger scskResp = scResp.responseForDeviceSecretKey(nameOfSmartcard);
          sValues.put(IssuanceSpec.SMARTCARD_SECRET, new SValue(scskResp));
        }

        final TreeMap<String, BigInteger> additionalValues = new TreeMap<String, BigInteger>();
        additionalValues.put(IssuanceSpec.vHatPrime, vHatPrime);

        Vector<BigInteger> tValues = new Vector<BigInteger>();
        final Proof proof1 = new Proof(challenge, sValues, tValues, additionalValues, smartcardNonce);

        n2 = Utils.computeRandomNumber(sp.getL_Phi());
        HashMap<IssuanceProtocolValues, BigInteger> issuanceProtocolValues = new HashMap<IssuanceProtocolValues, BigInteger>();
        issuanceProtocolValues.put(IssuanceProtocolValues.capU, capU);
        issuanceProtocolValues.put(IssuanceProtocolValues.nonce, n2);

        Message msg;
        msg = new Message(issuanceProtocolValues, proof1, 1);

        return msg;
    }
    
    private BigInteger computeCommitment(URI nameOfSmartcard, URI credNameOnSmartcard, IdemixProofCommitment scCom) {
      if (nameOfSmartcard != null) {
        return scCom.commitmentForCredential(nameOfSmartcard, credNameOnSmartcard);
      } else {
        return BigInteger.ONE;
      }
    }
    private BigInteger computeFragment(URI nameOfSmartcard, URI credNameOnSmartcard) {
      if (nameOfSmartcard != null) {
        return smartcardManager.computeCredentialFragment(nameOfSmartcard, credNameOnSmartcard); 
      } else {
        return BigInteger.ONE;
      }
    }
    /**
     * @param attStructs
     *            Attribute structures.
     * @param capCTilde
     *            Additional commitments for committed attribtues.
     * @param challenge
     *            Challenge of the proof.
     * @return S-values of the proof for the hidden/committed attributes and
     *         <tt>rHat</tt> values for the committed attributes.
     */
    private HashMap<String, SValue> getSValues(
            final Vector<AttributeStructure> attStructs,
            final HashMap<String, Commitment> capCTilde,
            final BigInteger challenge) {
        HashMap<String, SValue> sValues = new HashMap<String, SValue>(
                attStructs.size());

        for (AttributeStructure attStruct : attStructs) {
            final String theName = attStruct.getName();

            switch (attStruct.getIssuanceMode()) {
            case KNOWN:
                break;
            case COMMITTED:
                final CommitmentOpening commOpen = (CommitmentOpening) values
                        .get(attStruct.getName()).getContent();
                final CommitmentOpening comTilde = (CommitmentOpening) capCTilde
                        .get(theName);

                final BigInteger rHat = Utils.computeResponse(
                        comTilde.getRandom(), challenge, commOpen.getRandom());
                sValues.put(theName + Constants.DELIMITER + "rHat", new SValue(
                        rHat));
            case HIDDEN:
                BigInteger mHat = Utils.computeResponse(mTilde.get(theName),
                        challenge, (BigInteger) values.getValue(attStruct));
                sValues.put(theName, new SValue(mHat));
                break;
            default:
                throw new RuntimeException("Issuance mode not implemented.");
            }
        }
        return sValues;
    }

    /**
     * 
     * @see com.ibm.zurich.idmx.issuance.RecipientInterface#round3(com.ibm.zurich
     *      .idmx.issuance.Message)
     */
    public final Credential round3(final Message msg) {

        final BigInteger v = msg.getIssuanceElement(
                IssuanceProtocolValues.vPrimePrime).add(vPrime);
        final BigInteger e = msg.getIssuanceElement(IssuanceProtocolValues.e);
        final BigInteger n = ipk.getN();

        // [spec: IssueCertificateProtocol 3.1.0]
        if (!e.isProbablePrime(sp.getL_pt())) {
            log.log(Level.SEVERE, "e is not prime");
            return null;
        }
        final BigInteger lower = BigInteger.ONE.shiftLeft(sp.getL_e() - 1);
        final BigInteger upper = lower.add(BigInteger.ONE.shiftLeft(sp
                .getL_ePrime() - 1));
        if (!Utils.isInInterval(e, lower, upper)) {
            log.log(Level.SEVERE, "e not in proper interval");
            return null;
        }

        // [spec: IssueCertificateProtocol 3.1.1]
        final BigInteger fragment = computeFragment(nameOfSmartcard, credNameOnSmartcard);
        final BigInteger capQ = Issuer.computeQ(ipk.getCapS(), fragment,
          ipk.getCapZ(), ipk.getCapR(), v, ipk.getN(), credStruct
                  .getAttributeStructs(), values);

        // generated by Issuer and passed via appropriate message.
        final BigInteger capA = msg
                .getIssuanceElement(IssuanceProtocolValues.capA);
        // [spec: IssueCertificateProtocol 3.1.2]
        final BigInteger capQHat = capA.modPow(e, n);
        // [spec: IssueCertificateProtocol 3.1.3]
        if (!capQ.equals(capQHat)) {
            log.log(Level.SEVERE, "Q from issuer does not match the Q "
                    + "computed by recipient.");
            return null;
        }

        // [spec: IssueCertificateProtocol 3.2]
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        expos.add(new Exponentiation(capA, msg.getProof().getChallenge(), n));
        expos.add(new Exponentiation(capQ, (BigInteger) msg.getProof()
                .getSValue(IssuanceSpec.s_e).getValue(), n));
        final BigInteger capAHat = Utils.multiExpMul(expos, n);

        Vector<BigInteger> proofContext = new Vector<BigInteger>();
        proofContext.add(spec.getContext());
        proofContext.add(capQ);
        proofContext.add(capA);
        proofContext.add(n2);
        proofContext.add(capAHat);
        final BigInteger cHat = Utils.hashOf(sp.getL_H(), proofContext);

        if (!cHat.equals(msg.getProof().getChallenge())) {
            throw new RuntimeException("Verification failure! "
                    + "Mismatching cPrime, cHat");
        }

        Credential cred = new Credential(spec.getIssuerPublicKeyId(),
                spec.getCredStructureLocation(), capA, e, v, values,
                smartcardManager, credNameOnSmartcard, nameOfSmartcard);

        // set update location
        URI updateLocation = msg.getUpdateLocation();
        if (updateLocation != null) {
            cred.new UpdateInformation(capU, vPrime, updateLocation, n2,
                    spec.getContext());
        }

        return cred;
    }
}
